/*!
* chartjs-plugin-annotation v1.4.0
* https://www.chartjs.org/chartjs-plugin-annotation/index
 * (c) 2022 chartjs-plugin-annotation Contributors
 * Released under the MIT License
 */ !function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("chart.js"), require("chart.js/helpers")) : "function" == typeof define && define.amd ? define(["chart.js", "chart.js/helpers"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self)["chartjs-plugin-annotation"] = e(t.Chart, t.Chart.helpers) }(this, function (t, e) { "use strict"; let o = ["click", "dblclick"], i = ["enter", "leave"], r = o.concat(i); function n(t, o, i) { e.callback(t, [o.$context, i]) } function a(t, o) { let i = Number.POSITIVE_INFINITY; return t.filter(t => t.options.display && t.inRange(o.x, o.y)).reduce((t, r) => { let n = r.getCenterPoint(), a = e.distanceBetweenPoints(o, n); return a < i ? (t = [r], i = a) : a === i && t.push(r), t }, []).sort((t, e) => t._index - e._index).slice(0, 1)[0] } function l(t, o, i, r) { var n, a, l; if (e.isFinite(o[i]) && (n = t.options, a = i, l = r, !(e.defined(n[a]) || e.defined(n[l])))) { let s = t[i] !== o[i]; return t[i] = o[i], s } } function s(t, e) { for (let o of ["scaleID", "xScaleID", "yScaleID"]) t[o] && !e[t[o]] && d(t, o) && console.warn(`No scale found with id '${t[o]}' for annotation '${t.id}'`) } function d(t, o) { if ("scaleID" === o) return !0; let i = o.charAt(0); for (let r of ["Min", "Max", "Value"]) if (e.defined(t[i + r])) return !0; return !1 } function h(t, o, i, r) { for (let n of i) { let a = t[n]; if (e.defined(a)) { let l = o.parse(a); r.min = Math.min(r.min, l), r.max = Math.max(r.max, l) } } } let u = (t, e, o) => Math.min(o, Math.max(e, t)); function f(t, e, { x: o, y: i, width: r, height: n }, a) { let l = a / 2; return t >= o - l - .001 && t <= o + r + l + .001 && e >= i - l - .001 && e <= i + n + l + .001 } function c(t, e) { let { x: o, y: i } = t.getProps(["x", "y"], e); return { x: o, y: i } } let b = (t, e) => e > t || t.length > e.length && t.substr(0, e.length) === e, $ = t => "string" == typeof t && t.endsWith("%"), x = t => u(parseFloat(t) / 100, 0, 1); function y(t, e) { return "start" === e ? 0 : "end" === e ? t : $(e) ? x(e) * t : t / 2 } function p(t, e) { return "number" == typeof e ? e : $(e) ? x(e) * t : t } function g(t) { return e.isObject(t) ? { x: e.valueOrDefault(t.x, "center"), y: e.valueOrDefault(t.y, "center") } : { x: t = e.valueOrDefault(t, "center"), y: t } } function w(t) { return t && (e.defined(t.xValue) || e.defined(t.yValue)) } let v = new Map; function m(t) { if (t && "object" == typeof t) { let e = t.toString(); return "[object HTMLImageElement]" === e || "[object HTMLCanvasElement]" === e } } function S(t, o, i) { if (i) { let r = o.getCenterPoint(); t.translate(r.x, r.y), t.rotate(e.toRadians(i)), t.translate(-r.x, -r.y) } } function C(t, e) { if (e && e.borderWidth) return t.lineCap = e.borderCapStyle, t.setLineDash(e.borderDash), t.lineDashOffset = e.borderDashOffset, t.lineJoin = e.borderJoinStyle, t.lineWidth = e.borderWidth, t.strokeStyle = e.borderColor, !0 } function k(t, e) { t.shadowColor = e.backgroundShadowColor, t.shadowBlur = e.shadowBlur, t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY } function D(t, o) { let i = o.content; if (m(i)) return { width: p(i.width, o.width), height: p(i.height, o.height) }; let r = e.toFont(o.font), n = o.textStrokeWidth, a = e.isArray(i) ? i : [i], l = a.join() + r.string + n + (t._measureText ? "-spriting" : ""); if (!v.has(l)) { t.save(), t.font = r.string; let s = a.length, d = 0; for (let h = 0; h < s; h++) { let u = a[h]; d = Math.max(d, t.measureText(u).width + n) } t.restore(); let f = s * r.lineHeight + n; v.set(l, { width: d, height: f }) } return v.get(l) } function P(t, o, i) { let { x: r, y: n, width: a, height: l } = o; t.save(), k(t, i); let s = C(t, i); t.fillStyle = i.backgroundColor, t.beginPath(), e.addRoundedRectPath(t, { x: r, y: n, w: a, h: l, radius: function t(e, o, i) { for (let r of Object.keys(e)) e[r] = u(e[r], 0, i); return e }(e.toTRBLCorners(e.valueOrDefault(i.cornerRadius, i.borderRadius)), 0, Math.min(a, l) / 2) }), t.closePath(), t.fill(), s && (t.shadowColor = i.borderShadowColor, t.stroke()), t.restore() } function _(t, o, i) { let r = i.content; if (m(r)) { t.drawImage(r, o.x, o.y, o.width, o.height); return } let n = e.isArray(r) ? r : [r], a = e.toFont(i.font), l = a.lineHeight, s = function t(e, o) { let { x: i, width: r } = e, n = o.textAlign; return "center" === n ? i + r / 2 : "end" === n || "right" === n ? i + r : i }(o, i), d = o.y + l / 2 + i.textStrokeWidth / 2; t.save(), t.font = a.string, t.textBaseline = "middle", t.textAlign = i.textAlign, function t(e, o) { if (o.textStrokeWidth > 0) return e.lineJoin = "round", e.miterLimit = 2, e.lineWidth = o.textStrokeWidth, e.strokeStyle = o.textStrokeColor, !0 }(t, i) && n.forEach((e, o) => t.strokeText(e, s, d + o * l)), t.fillStyle = i.color, n.forEach((e, o) => t.fillText(e, s, d + o * l)), t.restore() } function I(t) { let { x: e, y: o, width: i, height: r } = t; return { x: e + i / 2, y: o + r / 2 } } function O(t, e, o) { let i = Math.cos(o), r = Math.sin(o), n = e.x, a = e.y; return { x: n + i * (t.x - n) - r * (t.y - a), y: a + r * (t.x - n) + i * (t.y - a) } } function A(t, o, i) { return o = "number" == typeof o ? o : t.parse(o), e.isFinite(o) ? t.getPixelForValue(o) : i } function R(t, e) { if (t) { let o = A(t, e.min, e.start), i = A(t, e.max, e.end); return { start: Math.min(o, i), end: Math.max(o, i) } } return { start: e.start, end: e.end } } function j(t, e) { let { chartArea: o, scales: i } = t, r = i[e.xScaleID], n = i[e.yScaleID], a = o.width / 2, l = o.height / 2; return r && (a = A(r, e.xValue, a)), n && (l = A(n, e.yValue, l)), { x: a, y: l } } function W(t, e) { let o = t.scales[e.xScaleID], i = t.scales[e.yScaleID], { top: r, left: n, bottom: a, right: l } = t.chartArea; if (!o && !i) return {}; let s = R(o, { min: e.xMin, max: e.xMax, start: n, end: l }); n = s.start, l = s.end; let d = R(i, { min: e.yMin, max: e.yMax, start: r, end: a }); return r = d.start, { x: n, y: r, x2: l, y2: a, width: l - n, height: (a = d.end) - r } } function T(t, e) { if (!w(e)) { let o = W(t, e), i = I(o), r = e.radius; return (!r || isNaN(r)) && (r = Math.min(o.width, o.height) / 2, e.radius = r), { x: i.x + e.xAdjust, y: i.y + e.yAdjust, width: 2 * r, height: 2 * r } } return function t(e, o) { let i = j(e, o); return { x: i.x + o.xAdjust, y: i.y + o.yAdjust, width: 2 * o.radius, height: 2 * o.radius } }(t, e) } class M extends t.Element { inRange(t, o, i) { let { x: r, y: n } = O({ x: t, y: o }, this.getCenterPoint(i), e.toRadians(-this.options.rotation)); return f(r, n, this.getProps(["x", "y", "width", "height"], i), this.options.borderWidth) } getCenterPoint(t) { return I(this.getProps(["x", "y", "width", "height"], t)) } draw(t) { t.save(), S(t, this, this.options.rotation), P(t, this, this.options), t.restore() } drawLabel(t) { let { x: o, y: i, width: r, height: n, options: a } = this, { label: l, borderWidth: s } = a, d = s / 2, h = g(l.position), u = e.toPadding(l.padding), f = D(t, l), c = { x: function t(e, o, i, r) { let { x: n, x2: a, width: l, options: s } = e, { xAdjust: d, borderWidth: h } = s.label; return E({ start: n, end: a, size: l }, { position: i.x, padding: { start: r.left, end: r.right }, adjust: d, borderWidth: h, size: o.width }) }(this, f, h, u), y: function t(e, o, i, r) { let { y: n, y2: a, height: l, options: s } = e, { yAdjust: d, borderWidth: h } = s.label; return E({ start: n, end: a, size: l }, { position: i.y, padding: { start: r.top, end: r.bottom }, adjust: d, borderWidth: h, size: o.height }) }(this, f, h, u), width: f.width, height: f.height }; t.save(), S(t, this, l.rotation), t.beginPath(), t.rect(o + d + u.left, i + d + u.top, r - s - u.width, n - s - u.height), t.clip(), _(t, c, l), t.restore() } resolveElementProperties(t, e) { return W(t, e) } } function E(t, e) { let { start: o, end: i } = t, { position: r, padding: { start: n, end: a }, adjust: l, borderWidth: s } = e, d = i - s - o - n - a - e.size; return o + s / 2 + l + n + y(d, r) } M.id = "boxAnnotation", M.defaults = { adjustScaleRange: !0, backgroundShadowColor: "transparent", borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderRadius: 0, borderShadowColor: "transparent", borderWidth: 1, cornerRadius: void 0, display: !0, label: { borderWidth: void 0, color: "black", content: null, drawTime: void 0, enabled: !1, font: { family: void 0, lineHeight: void 0, size: void 0, style: void 0, weight: "bold" }, height: void 0, padding: 6, position: "center", rotation: void 0, textAlign: "start", textStrokeColor: void 0, textStrokeWidth: 0, xAdjust: 0, yAdjust: 0, width: void 0 }, rotation: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, xMax: void 0, xMin: void 0, xScaleID: "x", yMax: void 0, yMin: void 0, yScaleID: "y" }, M.defaultRoutes = { borderColor: "color", backgroundColor: "color" }, M.descriptors = { label: { _fallback: !0 } }; let Y = (t, e, o) => ({ x: t.x + o * (e.x - t.x), y: t.y + o * (e.y - t.y) }), V = (t, e, o) => Y(e, o, Math.abs((t - e.y) / (o.y - e.y))).x, X = (t, e, o) => Y(e, o, Math.abs((t - e.x) / (o.x - e.x))).y, L = t => t * t; function H({ x: t, y: e, x2: o, y2: i }, { top: r, right: n, bottom: a, left: l }) { return !(t < l && o < l || t > n && o > n || e < r && i < r || e > a && i > a) } function B({ x: t, y: e }, o, { top: i, right: r, bottom: n, left: a }) { return t < a && (e = X(a, { x: t, y: e }, o), t = a), t > r && (e = X(r, { x: t, y: e }, o), t = r), e < i && (t = V(i, { x: t, y: e }, o), e = i), e > n && (t = V(n, { x: t, y: e }, o), e = n), { x: t, y: e } } class z extends t.Element { intersects(t, e, o = .001, i) { let { x: r, y: n, x2: a, y2: l } = this.getProps(["x", "y", "x2", "y2"], i), s = a - r, d = l - n, h = L(s) + L(d), u = 0 === h ? -1 : ((t - r) * s + (e - n) * d) / h, f, c; return u < 0 ? (f = r, c = n) : u > 1 ? (f = a, c = l) : (f = r + u * s, c = n + u * d), L(t - f) + L(e - c) <= o } labelIsVisible(t, e) { let o = this.options.label; return !!o && !!o.enabled && (!e || H(this.getProps(["x", "y", "x2", "y2"], t), e)) } isOnLabel(t, e, o) { if (!this.labelIsVisible(o)) return !1; let { labelX: i, labelY: r, labelWidth: n, labelHeight: a, labelRotation: l } = this.getProps(["labelX", "labelY", "labelWidth", "labelHeight", "labelRotation"], o), { x: s, y: d } = O({ x: t, y: e }, { x: i, y: r }, -l), h = this.options.label.borderWidth / 2 || 0, u = n / 2 + h, f = a / 2 + h; return s >= i - u - .001 && s <= i + u + .001 && d >= r - f - .001 && d <= r + f + .001 } inRange(t, e, o) { let i = L(this.options.borderWidth / 2); return this.intersects(t, e, i, o) || this.isOnLabel(t, e, o) } getCenterPoint() { return { x: (this.x2 + this.x) / 2, y: (this.y2 + this.y) / 2 } } draw(t) { let { x: e, y: o, x2: i, y2: r, options: n } = this; if (t.save(), !C(t, n)) return t.restore(); k(t, n); let a = Math.sqrt(Math.pow(i - e, 2) + Math.pow(r - o, 2)), { startOpts: l, endOpts: s, startAdjust: d, endAdjust: h } = function t(e) { let o = e.options, i = o.arrowHeads && o.arrowHeads.start, r = o.arrowHeads && o.arrowHeads.end; return { startOpts: i, endOpts: r, startAdjust: U(e, i), endAdjust: U(e, r) } }(this); t.translate(e, o), t.rotate(Math.atan2(r - o, i - e)), t.beginPath(), t.moveTo(0 + d, 0), t.lineTo(a - h, 0), t.shadowColor = n.borderShadowColor, t.stroke(), q(t, 0, d, l), q(t, a, -h, s), t.restore() } drawLabel(t, e) { if (!this.labelIsVisible(!1, e)) return; let { labelX: o, labelY: i, labelWidth: r, labelHeight: n, labelRotation: a, labelPadding: l, labelTextSize: s, options: { label: d } } = this; t.save(), t.translate(o, i), t.rotate(a), P(t, { x: -(r / 2), y: -(n / 2), width: r, height: n }, d); let h = { x: -(r / 2) + l.left + d.borderWidth / 2, y: -(n / 2) + l.top + d.borderWidth / 2, width: s.width, height: s.height }; _(t, h, d), t.restore() } resolveElementProperties(t, o) { let i = t.scales[o.scaleID], { top: r, left: n, bottom: a, right: l } = t.chartArea, s, d; if (i) s = A(i, o.value, NaN), d = A(i, o.endValue, s), i.isHorizontal() ? (n = s, l = d) : (r = s, a = d); else { let h = t.scales[o.xScaleID], u = t.scales[o.yScaleID]; h && (n = A(h, o.xMin, n), l = A(h, o.xMax, l)), u && (r = A(u, o.yMin, r), a = A(u, o.yMax, a)) } let f = H({ x: n, y: r, x2: l, y2: a }, t.chartArea), c = f ? function t(e, o, i) { let { x: r, y: n } = B(e, o, i), { x: a, y: l } = B(o, e, i); return { x: r, y: n, x2: a, y2: l, width: Math.abs(a - r), height: Math.abs(l - n) } }({ x: n, y: r }, { x: l, y: a }, t.chartArea) : { x: n, y: r, x2: l, y2: a, width: Math.abs(l - n), height: Math.abs(a - r) }, b = o.label; return b && b.content ? function t(o, i, r) { var n, a, l; let s, { padding: d, xPadding: h, yPadding: u, borderWidth: f } = r, c = (n = d, a = h, l = u, s = n, (a || l) && (s = { x: a || 6, y: l || 6 }), e.toPadding(s)), b = D(i.ctx, r), $ = b.width + c.width + f, x = b.height + c.height + f, p = function t(o, i, r, n) { let { width: a, height: l, padding: s } = r, { xAdjust: d, yAdjust: h } = i, u = { x: o.x, y: o.y }, f = { x: o.x2, y: o.y2 }, c = "auto" === i.rotation ? function t(o) { let { x: i, y: r, x2: n, y2: a } = o, l = Math.atan2(a - r, n - i); return l > e.PI / 2 ? l - e.PI : l < -(e.PI / 2) ? l + e.PI : l }(o) : e.toRadians(i.rotation), b = function t(e, o, i) { let r = Math.cos(i), n = Math.sin(i); return { w: Math.abs(e * r) + Math.abs(o * n), h: Math.abs(e * n) + Math.abs(o * r) } }(a, l, c), $ = function t(e, o, i, r) { let n, a = function t(e, o) { let { x: i, x2: r, y: n, y2: a } = e, l = Math.min(n, a) - o.top, s = Math.min(i, r) - o.left, d = o.bottom - Math.max(n, a), h = o.right - Math.max(i, r); return { x: Math.min(s, h), y: Math.min(l, d), dx: s <= h ? 1 : -1, dy: l <= d ? 1 : -1 } }(e, r); return "start" === o.position ? J({ w: e.x2 - e.x, h: e.y2 - e.y }, i, o, a) : "end" === o.position ? 1 - J({ w: e.x - e.x2, h: e.y - e.y2 }, i, o, a) : y(1, o.position) }(o, i, { labelSize: b, padding: s }, n), x = Y(u, f, $), p = { size: b.w, min: n.left, max: n.right, padding: s.left }, g = { size: b.h, min: n.top, max: n.bottom, padding: s.top }; return { x: N(x.x, p) + d, y: N(x.y, g) + h, width: a, height: l, rotation: c } }(o, r, { width: $, height: x, padding: c }, i.chartArea); return o.labelX = p.x, o.labelY = p.y, o.labelWidth = p.width, o.labelHeight = p.height, o.labelRotation = p.rotation, o.labelPadding = c, o.labelTextSize = b, o }(c, t, b) : c } } z.id = "lineAnnotation"; let F = { backgroundColor: void 0, backgroundShadowColor: void 0, borderColor: void 0, borderDash: void 0, borderDashOffset: void 0, borderShadowColor: void 0, borderWidth: void 0, enabled: void 0, fill: void 0, length: void 0, shadowBlur: void 0, shadowOffsetX: void 0, shadowOffsetY: void 0, width: void 0 }; function J(t, e, o, i) { let { labelSize: r, padding: n } = e, a = t.w * i.dx, l = t.h * i.dy, s = a > 0 && (r.w / 2 + n.left - i.x) / a, d = l > 0 && (r.h / 2 + n.top - i.y) / l; return u(Math.max(s, d), 0, .25) } function N(t, e) { let { size: o, min: i, max: r, padding: n } = e, a = o / 2; return o > r - i ? (r + i) / 2 : (i >= t - n - a && (t = i + n + a), r <= t + n + a && (t = r - n - a), t) } function U(t, e) { if (!e || !e.enabled) return 0; let { length: o, width: i } = e, r = t.options.borderWidth / 2; return Math.abs(V(0, { x: o, y: i + r }, { x: 0, y: r })) } function q(t, e, o, i) { if (!i || !i.enabled) return; let { length: r, width: n, fill: a, backgroundColor: l, borderColor: s } = i, d = Math.abs(e - r) + o; t.beginPath(), k(t, i), C(t, i), t.moveTo(d, -n), t.lineTo(e + o, 0), t.lineTo(d, n), !0 === a ? (t.fillStyle = l || s, t.closePath(), t.fill(), t.shadowColor = "transparent") : t.shadowColor = i.borderShadowColor, t.stroke() } z.defaults = { adjustScaleRange: !0, arrowHeads: { enabled: !1, end: Object.assign({}, F), fill: !1, length: 12, start: Object.assign({}, F), width: 6 }, borderDash: [], borderDashOffset: 0, borderShadowColor: "transparent", borderWidth: 2, display: !0, endValue: void 0, label: { backgroundColor: "rgba(0,0,0,0.8)", backgroundShadowColor: "transparent", borderCapStyle: "butt", borderColor: "black", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderRadius: 6, borderShadowColor: "transparent", borderWidth: 0, color: "#fff", content: null, cornerRadius: void 0, drawTime: void 0, enabled: !1, font: { family: void 0, lineHeight: void 0, size: void 0, style: void 0, weight: "bold" }, height: void 0, padding: 6, position: "center", rotation: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, textAlign: "center", textStrokeColor: void 0, textStrokeWidth: 0, width: void 0, xAdjust: 0, xPadding: void 0, yAdjust: 0, yPadding: void 0 }, scaleID: void 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, value: void 0, xMax: void 0, xMin: void 0, xScaleID: "x", yMax: void 0, yMin: void 0, yScaleID: "y" }, z.descriptors = { arrowHeads: { start: { _fallback: !0 }, end: { _fallback: !0 }, _fallback: !0 } }, z.defaultRoutes = { borderColor: "color" }; class G extends t.Element { inRange(t, o, i) { return function t(o, i, r, n) { let { width: a, height: l } = i, s = i.getCenterPoint(!0), d = a / 2, h = l / 2; if (d <= 0 || h <= 0) return !1; let u = e.toRadians(r || 0), f = n / 2 || 0, c = Math.cos(u), b = Math.sin(u), $ = Math.pow(c * (o.x - s.x) + b * (o.y - s.y), 2), x = Math.pow(b * (o.x - s.x) - c * (o.y - s.y), 2); return $ / Math.pow(d + f, 2) + x / Math.pow(h + f, 2) <= 1.0001 }({ x: t, y: o }, this.getProps(["width", "height"], i), this.options.rotation, this.options.borderWidth) } getCenterPoint(t) { return I(this.getProps(["x", "y", "width", "height"], t)) } draw(t) { let { width: o, height: i, options: r } = this, n = this.getCenterPoint(); t.save(), S(t, this, r.rotation), k(t, this.options), t.beginPath(), t.fillStyle = r.backgroundColor; let a = C(t, r); t.ellipse(n.x, n.y, i / 2, o / 2, e.PI / 2, 0, 2 * e.PI), t.fill(), a && (t.shadowColor = r.borderShadowColor, t.stroke()), t.restore() } resolveElementProperties(t, e) { return W(t, e) } } G.id = "ellipseAnnotation", G.defaults = { adjustScaleRange: !0, backgroundShadowColor: "transparent", borderDash: [], borderDashOffset: 0, borderShadowColor: "transparent", borderWidth: 1, display: !0, rotation: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, xMax: void 0, xMin: void 0, xScaleID: "x", yMax: void 0, yMin: void 0, yScaleID: "y" }, G.defaultRoutes = { borderColor: "color", backgroundColor: "color" }; class K extends t.Element { inRange(t, o, i) { let { x: r, y: n } = O({ x: t, y: o }, this.getCenterPoint(i), e.toRadians(-this.options.rotation)); return f(r, n, this.getProps(["x", "y", "width", "height"], i), this.options.borderWidth) } getCenterPoint(t) { return I(this.getProps(["x", "y", "width", "height"], t)) } draw(t) { if (!this.options.content) return; let { labelX: o, labelY: i, labelWidth: r, labelHeight: n, options: a } = this; t.save(), S(t, this, a.rotation), function t(o, i) { let { pointX: r, pointY: n, calloutPosition: a, options: l } = i; if (!a || i.inRange(r, n)) return; let s = l.callout; o.save(), o.beginPath(); let d = C(o, s); if (!d) return o.restore(); let { separatorStart: h, separatorEnd: u } = function t(e, o) { let { x: i, y: r, width: n, height: a } = e, l = function t(e, o) { let { width: i, height: r, options: n } = e, a = n.callout.margin + n.borderWidth / 2; return "right" === o ? i + a : "bottom" === o ? r + a : -a }(e, o), s, d; return d = "left" === o || "right" === o ? { x: (s = { x: i + l, y: r }).x, y: s.y + a } : { x: (s = { x: i, y: r + l }).x + n, y: s.y }, { separatorStart: s, separatorEnd: d } }(i, a), { sideStart: f, sideEnd: c } = function t(e, o, i) { let { y: r, width: n, height: a, options: l } = e, s = l.callout.start, d = function t(e, o) { let i = o.side; return "left" === e || "top" === e ? -i : i }(o, l.callout), h, u; return u = "left" === o || "right" === o ? { x: (h = { x: i.x, y: r + p(a, s) }).x + d, y: h.y } : { x: (h = { x: i.x + p(n, s), y: i.y }).x, y: h.y + d }, { sideStart: h, sideEnd: u } }(i, a, h); (s.margin > 0 || 0 === l.borderWidth) && (o.moveTo(h.x, h.y), o.lineTo(u.x, u.y)), o.moveTo(f.x, f.y), o.lineTo(c.x, c.y); let b = O({ x: r, y: n }, i.getCenterPoint(), e.toRadians(-l.rotation)); o.lineTo(b.x, b.y), o.stroke(), o.restore() }(t, this), P(t, this, a), _(t, { x: o, y: i, width: r, height: n }, a), t.restore() } resolveElementProperties(t, o) { let i = w(o) ? j(t, o) : I(W(t, o)), r = e.toPadding(o.padding), n = D(t.ctx, o), a = function t(e, o, i, r) { let n = o.width + r.width + i.borderWidth, a = o.height + r.height + i.borderWidth, l = g(i.position); return { x: Q(e.x, n, i.xAdjust, l.x), y: Q(e.y, a, i.yAdjust, l.y), width: n, height: a } }(i, n, o, r), l = o.borderWidth / 2, s = { pointX: i.x, pointY: i.y, ...a, labelX: a.x + r.left + l, labelY: a.y + r.top + l, labelWidth: n.width, labelHeight: n.height }; return s.calloutPosition = o.callout.enabled && function t(o, i, r) { let n = i.position; return "left" === n || "right" === n || "top" === n || "bottom" === n ? n : function t(o, i, r) { let { x: n, y: a, width: l, height: s, pointX: d, pointY: h } = o, u = { x: n + l / 2, y: a + s / 2 }, f = i.start, c = p(l, f), b = p(s, f), $ = [n, n + c, n + c, n + l], x = [a + b, a + s, a, a + b], y = []; for (let g = 0; g < 4; g++) { let w = O({ x: $[g], y: x[g] }, u, e.toRadians(r)); y.push({ position: Z[g], distance: e.distanceBetweenPoints(w, { x: d, y: h }) }) } return y.sort((t, e) => t.distance - e.distance)[0].position }(o, i, r) }(s, o.callout, o.rotation), s } } function Q(t, e, o = 0, i) { return t - y(e, i) + o } K.id = "labelAnnotation", K.defaults = { adjustScaleRange: !0, backgroundColor: "transparent", backgroundShadowColor: "transparent", borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderRadius: 0, borderShadowColor: "transparent", borderWidth: 0, callout: { borderCapStyle: "butt", borderColor: void 0, borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 1, enabled: !1, margin: 5, position: "auto", side: 5, start: "50%" }, color: "black", content: null, display: !0, font: { family: void 0, lineHeight: void 0, size: void 0, style: void 0, weight: void 0 }, height: void 0, padding: 6, position: "center", rotation: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, textAlign: "center", textStrokeColor: void 0, textStrokeWidth: 0, width: void 0, xAdjust: 0, xMax: void 0, xMin: void 0, xScaleID: "x", xValue: void 0, yAdjust: 0, yMax: void 0, yMin: void 0, yScaleID: "y", yValue: void 0 }, K.defaultRoutes = { borderColor: "color" }; let Z = ["left", "bottom", "top", "right"]; class tt extends t.Element { inRange(t, e, o) { var i, r, n, a; let { width: l } = this.getProps(["width"], o); return i = { x: t, y: e }, r = this.getCenterPoint(o), n = l / 2, a = this.options.borderWidth, !!i && !!r && !(n <= 0) && Math.pow(i.x - r.x, 2) + Math.pow(i.y - r.y, 2) <= Math.pow(n + (a / 2 || 0), 2) } getCenterPoint(t) { return c(this, t) } draw(t) { let o = this.options, i = o.borderWidth; if (o.radius < .1) return; t.save(), t.fillStyle = o.backgroundColor, k(t, o); let r = C(t, o); o.borderWidth = 0, e.drawPoint(t, o, this.x, this.y), r && !m(o.pointStyle) && (t.shadowColor = o.borderShadowColor, t.stroke()), t.restore(), o.borderWidth = i } resolveElementProperties(t, e) { return T(t, e) } } tt.id = "pointAnnotation", tt.defaults = { adjustScaleRange: !0, backgroundShadowColor: "transparent", borderDash: [], borderDashOffset: 0, borderShadowColor: "transparent", borderWidth: 1, display: !0, pointStyle: "circle", radius: 10, rotation: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, xAdjust: 0, xMax: void 0, xMin: void 0, xScaleID: "x", xValue: void 0, yAdjust: 0, yMax: void 0, yMin: void 0, yScaleID: "y", yValue: void 0 }, tt.defaultRoutes = { borderColor: "color", backgroundColor: "color" }; class te extends t.Element { inRange(t, e, o) { return this.options.radius >= .1 && this.elements.length > 1 && function t(e, o, i, r) { let n = !1, a = e[e.length - 1].getProps(["bX", "bY"], r); for (let l of e) { let s = l.getProps(["bX", "bY"], r); s.bY > i != a.bY > i && o < (a.bX - s.bX) * (i - s.bY) / (a.bY - s.bY) + s.bX && (n = !n), a = s } return n }(this.elements, t, e, o) } getCenterPoint(t) { return c(this, t) } draw(t) { let { elements: e, options: o } = this; t.save(), t.beginPath(), t.fillStyle = o.backgroundColor, k(t, o); let i = C(t, o), r = !0; for (let n of e) r ? (t.moveTo(n.x, n.y), r = !1) : t.lineTo(n.x, n.y); t.closePath(), t.fill(), i && (t.shadowColor = o.borderShadowColor, t.stroke()), t.restore() } resolveElementProperties(t, o) { let { x: i, y: r, width: n, height: a } = T(t, o), { sides: l, radius: s, rotation: d, borderWidth: h } = o, u = h / 2, f = [], c = 2 * e.PI / l, b = d * e.RAD_PER_DEG; for (let $ = 0; $ < l; $++, b += c) { let x = Math.sin(b), y = Math.cos(b); f.push({ type: "point", optionScope: "point", properties: { x: i + x * s, y: r - y * s, bX: i + x * (s + u), bY: r - y * (s + u) } }) } return { x: i, y: r, width: n, height: a, elements: f, initProperties: { x: i, y: r } } } } te.id = "polygonAnnotation", te.defaults = { adjustScaleRange: !0, backgroundShadowColor: "transparent", borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderShadowColor: "transparent", borderWidth: 1, display: !0, point: { radius: 0 }, radius: 10, rotation: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, sides: 3, xAdjust: 0, xMax: void 0, xMin: void 0, xScaleID: "x", xValue: void 0, yAdjust: 0, yMax: void 0, yMin: void 0, yScaleID: "y", yValue: void 0 }, te.defaultRoutes = { borderColor: "color", backgroundColor: "color" }; let to = { box: M, ellipse: G, label: K, line: z, point: tt, polygon: te }; Object.keys(to).forEach(e => { t.defaults.describe(`elements.${to[e].id}`, { _fallback: "plugins.annotation" }) }); let ti = { update: Object.assign }; function tr(t = "line") { return to[t] ? t : (console.warn(`Unknown annotation type: '${t}', defaulting to 'line'`), "line") } function tn(t) { return isNaN(t.x) || isNaN(t.y) } function ta(t, { elements: e, initProperties: o }, i, r) { let n = t.elements || (t.elements = []); n.length = e.length; for (let a = 0; a < e.length; a++) { let l = e[a], s = l.properties, d = tl(n, a, l.type, o), h = i[l.optionScope].override(l); s.options = ts(h), r.update(d, s) } } function tl(t, o, i, r) { let n = to[tr(i)], a = t[o]; return a && a instanceof n || (a = t[o] = new n, e.isObject(r) && Object.assign(a, r)), a } function ts(t) { let e = to[tr(t.type)], o = {}; for (let i of (o.id = t.id, o.type = t.type, o.drawTime = t.drawTime, Object.assign(o, td(t, e.defaults), td(t, e.defaultRoutes)), r)) o[i] = t[i]; return o } function td(t, o) { let i = {}; for (let r of Object.keys(o)) { let n = o[r], a = t[r]; i[r] = e.isObject(n) ? td(a, n) : a } return i } function th(t, e, o) { return e.$context || (e.$context = Object.assign(Object.create(t.getContext()), { element: e, id: o.id, type: "annotation" })) } let tu = new Map; var tf = { id: "annotation", version: "1.4.0", afterRegister() { t.Chart.register(to), !function t(e, o, i, r = !0) { let n = i.split("."), a = 0; for (let l of o.split(".")) { let s = n[a++]; if (parseInt(l, 10) < parseInt(s, 10)) break; if (b(s, l)) { if (!r) return !1; throw Error(`${e} v${i} is not supported. v${o} or newer is required.`) } } return !0 }("chart.js", "3.7", t.Chart.version, !1) && (console.warn("chartjs-plugin-annotation has known issues with chart.js versions prior to 3.7, please consider upgrading."), t.Chart.defaults.set("elements.lineAnnotation", { callout: {}, font: {}, padding: 6 })) }, afterUnregister() { t.Chart.unregister(to) }, beforeInit(t) { tu.set(t, { annotations: [], elements: [], visibleElements: [], listeners: {}, listened: !1, moveListened: !1 }) }, beforeUpdate(t, o, i) { let r = tu.get(t), n = r.annotations = [], a = i.annotations; e.isObject(a) ? Object.keys(a).forEach(t => { let o = a[t]; e.isObject(o) && (o.id = t, n.push(o)) }) : e.isArray(a) && n.push(...a), function t(e, o) { for (let i of e) s(i, o) }(n, t.scales) }, afterDataLimits(t, o) { let i = tu.get(t); !function t(o, i, r) { let n = function t(o, i) { let r = o.axis, n = o.id, a = r + "ScaleID", l = { min: e.valueOrDefault(o.min, Number.NEGATIVE_INFINITY), max: e.valueOrDefault(o.max, Number.POSITIVE_INFINITY) }; for (let s of i) s.scaleID === n ? h(s, o, ["value", "endValue"], l) : s[a] === n && h(s, o, [r + "Min", r + "Max", r + "Value"], l); return l }(i, r), a = l(i, n, "min", "suggestedMin"); (a = l(i, n, "max", "suggestedMax") || a) && "function" == typeof i.handleTickRangeOptions && i.handleTickRangeOptions() }(t, o.scale, i.annotations.filter(t => t.display && t.adjustScaleRange)) }, afterUpdate(n, a, l) { var s, d, h; let u = tu.get(n); d = u, h = l, d.listened = !1, d.moveListened = !1, r.forEach(t => { "function" == typeof h[t] ? (d.listened = !0, d.listeners[t] = h[t]) : e.defined(d.listeners[t]) && delete d.listeners[t] }), i.forEach(t => { "function" == typeof h[t] && (d.moveListened = !0) }), d.listened && d.moveListened || d.annotations.forEach(t => { d.listened || o.forEach(e => { "function" == typeof t[e] && (d.listened = !0) }), d.moveListened || i.forEach(e => { "function" == typeof t[e] && (d.listened = !0, d.moveListened = !0) }) }), function o(i, r, n, a) { var l, s, d; let h = (l = i, s = n.animations, d = a, "reset" === d || "none" === d || "resize" === d ? ti : new t.Animations(l, s)), u = r.annotations, f = function t(e, o) { let i = o.length, r = e.length; return r < i ? e.splice(r, 0, ...Array(i - r)) : r > i && e.splice(i, r - i), e }(r.elements, u); for (let c = 0; c < u.length; c++) { let b = u[c], $ = tl(f, c, b.type), x = b.setContext(th(i, $, b)), y = $.resolveElementProperties(i, x); y.skip = tn(y), "elements" in y && (ta($, y, x, h), delete y.elements), e.defined($.x) || Object.assign($, y), y.options = ts(x), h.update($, y) } }(n, u, l, a.mode), u.visibleElements = u.elements.filter(t => !t.skip && t.options.display) }, beforeDatasetsDraw(t, e, o) { tc(t, "beforeDatasetsDraw", o.clip) }, afterDatasetsDraw(t, e, o) { tc(t, "afterDatasetsDraw", o.clip) }, beforeDraw(t, e, o) { tc(t, "beforeDraw", o.clip) }, afterDraw(t, e, o) { tc(t, "afterDraw", o.clip) }, beforeEvent(t, e, o) { let i = tu.get(t); !function t(e, o, i) { if (e.listened) switch (o.type) { case "mousemove": case "mouseout": !function t(e, o) { if (!e.moveListened) return; let i; "mousemove" === o.type && (i = a(e.elements, o)); let r = e.hovered; e.hovered = i, function t(e, o, i) { let { previous: r, element: a } = o; r && r !== a && n(r.options.leave || e.listeners.leave, r, i), a && a !== r && n(a.options.enter || e.listeners.enter, a, i) }(e, { previous: r, element: i }, o) }(e, o); break; case "click": !function t(e, o, i) { let r = e.listeners, l = a(e.elements, o); if (l) { let s = l.options, d = s.dblclick || r.dblclick, h = s.click || r.click; l.clickTimeout ? (clearTimeout(l.clickTimeout), delete l.clickTimeout, n(d, l, o)) : d ? l.clickTimeout = setTimeout(() => { delete l.clickTimeout, n(h, l, o) }, i.dblClickSpeed) : n(h, l, o) } }(e, o, i) } }(i, e.event, o) }, destroy(t) { tu.delete(t) }, _getState: t => tu.get(t), defaults: { animations: { numbers: { properties: ["x", "y", "x2", "y2", "width", "height", "pointX", "pointY", "labelX", "labelY", "labelWidth", "labelHeight", "radius"], type: "number" } }, clip: !0, dblClickSpeed: 350, drawTime: "afterDatasetsDraw", label: { drawTime: null } }, descriptors: { _indexable: !1, _scriptable: t => !r.includes(t), annotations: { _allKeys: !1, _fallback: (t, e) => `elements.${to[tr(e.type)].id}` } }, additionalOptionScopes: [""] }; function tc(t, o, i) { let { ctx: r, chartArea: n } = t, { visibleElements: a } = tu.get(t); i && e.clipArea(r, n), tb(r, a, o), function t(o, i, r) { for (let n of i) e.isArray(n.elements) && tb(o, n.elements, r) }(r, a, o), i && e.unclipArea(r), a.forEach(t => { if (!("drawLabel" in t)) return; let e = t.options.label; e && e.enabled && e.content && (e.drawTime || t.options.drawTime) === o && t.drawLabel(r, n) }) } function tb(t, e, o) { for (let i of e) i.options.drawTime === o && i.draw(t) } return t.Chart.register(tf), tf });